# 64bit 멀티코어 OS 제작하기
한승훈 저자님의 "64비트 멀티코어 OS 원리와 구조" 책을 학습하면서 OS와 코드를 정리하였습니다.
한승훈 저자님 감사합니다.

## 멀티코어 환경설정
OS : Ubuntu 16.04.06 LTS
editor : vim

### 1. 필수 패키지 설치
ubuntu에서 작업을 실행하면 gcc 패키지와 g++패키지는 기본 패키지로 설치되어 있습니다. 우리가 지금 사용하고 있는 운영체제는 64bit로 gcc패키지와 g++패키지 또한 64bit로 되어있습니다. 그래서 32bit로 된 gcc패키지와 g++패키지가 필요합니다. 이때 크로스 컴파일링을 위한 gcc-multilib패키지와 g++-multilib, 크로스 컴파일을 위한 패키지 등을 설치해야 합니다.

**필수 패키지 종류**

	1. binutils : 여러 종류의 오브젝트 파일들을 핸들링하기 위한 바이너리들입니다. 주로 make패키지, gcc패키지, gdb 패키지 등과 함께 사용됩니다.
	2. bison : Parser의 일종으로, LALR(Lock-Ahead LR)로 이루어진 문법을 해석하여 C코드로 작성해줍니다.
	3. flex : lex(구문분석기)의 향상된 버전으로 bison과 함께 구문분석을 위해서 사용합니다. 
	4. gcc-multilib : C의 크로스 컴파일을 위해 설치합니다. 
	5. g++-multilib : C++의 크로스 컴파일을 위해 설치합니다.
	6. libc6-dev : libiconv(인코딩 변환 라이브러리)를 사용하기 위해 설치합니다.
	7. libtool : Portable library를 만들기 위한 도구입니다.
	8. make : 프로그램 그룹 유지를 위한 유틸리티로, 컴파일이 필요한 부분을 읽어서 gcc컴파일로 컴파일한다.
	9. patchutils : 패치 파일을 핸들링하기 위한 유틸리티입니다.
	10. libgmp-dev : GNU MP(GNU Multiple Precision Arithmetic Library) 라이브러리를 사용하기 위해 설치합니다.
	11. libmpfr-dev : GNU MPFR(GNU Multiple Precision Floating-Point Reliably Library) 라이브러리를 사용하기 위해 설치합니다.
	12. libmpc-dev : MPC(Music Player Daemon) 라이브러리를 사용하기 위해 설치합니다.

**패키지 설치 과정**
미리 패키지를 설치했다면, 설치한 패키지는 건너띄고 명령어를 입력합니다.
```
$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo apt-get install gcc-multilib
$ sudo apt-get install g++-multilib
$ sudo apt-get install binutils
$ sudo apt-get install bison
$ sudo apt-get install flex
$ sudo apt-get install libc6-dev
$ sudo apt-get install libtool
$ sudo apt-get install make
$ sudo apt-get install patchutils
$ sudo apt-get install libgmp-dev
$ sudo apt-get install libmpfr-dev
```

**크로스 컴파일링 라이브러리가 설치되어 있는지 적용**
[test.c]
```
#include <stdio.h>
int main(int argv, char* argc[]){
	printf("Hello World\n");
	return 0;
}
```
설치한 크로스 컴파일 gcc 컴파일로 test.c 파일을 32비트와 64비트 컴파일합니다.
```
$ gcc -m32 -o test32 test.c
$ gcc -m64 -o test64 test.c
```

[test.cpp]
```
#include <iostream>
int main(int argv, char* argc[]){
	std::cout << "Hello World" << std::endl;
	return 0;
}
```
설치한 크로스 컴파일 gcc 컴파일로 test.c 파일을 32비트와 64비트 컴파일합니다.
```
$ g++ -m32 -o test32 test.c
$ g++ -m64 -o test64 test.c
```

### 2. NASM 설치
NASM(The Netwide Assembler)은 윈도우와 리눅스 등 다양한 플랫폼을 지원하는 우수한 어셈블러입니다. NASM은 32비트와 64비트 환경에서 모두 지원합니다. 
**NASM 설치**
```
$ sudo apt-get install nasm
```

### 3. QEMU 설치
QEMU는 오픈 소스 프로세서 에뮬레이터로 다양한 종류의 프로세서를 소프트웨어적으로 구현한 프로그램입니다. QEMU는 하드웨어 가상화의 기능을 갖춘것으로 KVM(keyboard, Video Monitor, Mouse)을 적용할 수 있으며, 리눅스에서 사용하는 가상 머신의 표준이다. 하이퍼바이저에서 채택하고 있습니다.
```
$ sudo apt-get install qemu-kvm
```

## 운영 모드
| 운영모드 | 설명 |
|---|---:|
| `리얼 모드` | 프로세스 초기 상태로 16비트 모드로 동작한다. 최대 1MB 주소 공간 지원 |
| `보호 모드` | 32비트 모드로 동작하며 세그먼트, 페이징, 보호, 멀티태스킹 등의 기능을 제공한다. 4GB 주소 공간 지원 |
| `IA-32e 모드` | 32비트 호환 모드와 64비트 모드를 서브 모드로 구성한다. 16EB 주소 공간 지원 |
| `시스템 관리 모드` | 전원 관리나 하드웨어 제어 같은 특수 기능을 제공한다. | 
| `가상 8086모드` | 보호 모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작한다. |

### 64비트 OS가 갖추어야할 운영 모드
위 다섯 가지 모드 중에 64비트 OS가 반드시 지원해야 모드는 세가지이다. 리얼 모드, 보호 모드, IA-32e 모드 중 64비트 서브모드가 해당합니다. 이와 반대로 시스템 관리 모드와 가상 8086모드는 특수한 상황에서 사용되는 OS 모드로 반드시 필요한 필요한 것은 아닙니다.   
앞으로 만들 64비트 멀티코어 OS는 전원 관리 기능이나 보호 모드에서 16비트 코드를 실행하는 기능을 지원하지 않음으로 시스템 관리 모드와 가상 8086모드를 구현하지 구현하지 않는다. 오직 리얼 모드, 보호 모드, IA-32e 모드의 64비트 서브 모드를 구현한다.   

### 리얼 모드
프로세스가 어떤 상태 또는 모드에 있든 전원이 켜지거나 리셋되면 프로세스는 리얼 모드로 진입합니다. 리얼모드는 BIOS(Basic Input Output System)의 여러 기능을 사용할 수 있습니다. BIOS는 디스크 읽기 및 쓰기 기능부터 그래픽 모드로 전환하는 기능까지 여러 가지 기능을 제공합니다. 
리얼 모드에서 하는 작업은 OS 이미지를 디스크에서 메모리로 복사하여 보호 모드로 변경하는 것밖에 없지만, 대부분의 작업을 어셈블리어로 처리해야 한다.  

### 보호 모드
보호 모드는 IA-32e 모드로 전환하려면 반드시 거쳐야 하는 모드로, 32비트 윈도우나 리눅스 OS가 동작하는 기본 모드입니다. 최대 4G 주소 공간을 제공하며 OS의 필수 기능으로 자리 잡은 보호, 멀티태스킹, 세그먼테이션, 페이징 등의 기능을 하드웨어적으로 지원합니다. 보호 모드에서 사용하는 레지스터는 대부분 IA-32e 모드에서도 같이 사용합니다. 

### IA-32e 모드
IA-32e 모드에서는 서브모드로 32비트 호환 모드와 64비트 모드가 존재합니다. 32비트 호환 모드는 보호 모드와 같은 기능을 수행하므로 64비트 모드가 주요 실행 OS 기능이 될 것입니다. IA-32e 모든느 최대 16EB 주소 공간을 제공하며 레지스터 수도 보호모드보다 많습니다. 이 때 64비트 OS에서는 서브 모드만 변경함으로써 32비트 보호 모드를 별다른 처리 없이 그대로 실행할 수 있습니다. 

## 운영모드와 레지스터
운영 모드를 비트 크기로 분류하면 16비트 모드, 32비트 모드, 64비트 모드 세가지 모드로 나눌 수 있다. 운영 모드 앞에 붙은 숫자가 클수록 레지스터의 크기와 숫자가 커진다. 

### 범용 레지스터
범용 레지스터(General Purpose Register)는 운영 모드와 관련있는 레지스터입니다. 범용 레지스터는 계산, 메모리 어드레스 지정, 임시 저장 공간 등의 목적으로 사용합니다. 16비트와 32비트 모드를 지원하는 x86 계열은 8개의 범용 레지스터가 필요하고, 64비트를 지원하는 x86-64 계열은 16개의 범용 레지스터가 필요합니다.

**범용 레지스터의 역할**
	1. 수행 속도의 개선
	2. 범용 레지스터의 용도는 고정된 것이 아니며, 다양한 목적으로 사용 가능
	3. 특정 명령어에 특정 레지스터를 사용
	4. 범용 레지스터는 개별적인 이름을 가지고 있어, 이름을 통해 역할을 알 수 있다.

**x86-64 프로세서의 범용 레지스터와 용도**
| 범용 레지스터 이름 | 용도 |
|---|---:|
| `AX` | 산술 연산을 수행할 때 누산기로 사용 |
| `BX` | 데이터의 어드레스를 지정할 때 데이터 포인터로 사용 |
| `CX` | 루프 또는 문자열의 카운터로 사용 |
| `DX` | I/O 어드레스를 지정할 때 사용되며, 산술 연산을 수행할 때 보조 레지스터로 사용 | 
| `SI` | 문자열에 관련된 작업을 수행할 때 원본 문자열의 인덱스로 사용 |
| `DI` | 문자열에 관련된 작업을 수행할 때 목적지 문자열의 인덱스로 사용 |
| `SP` | 스택의 포인터로 사용 |
| `BP` | 스택의 데이터에 접근할 때 데이터의 포인터로 사용 | 
| `R8 ~ R15` | X86-64 프로세서에서 추가된 범용 레지스터로, 다양한 용도로 사용 가능 |

**RIP 레지스터**
현재 수행 중인 명령의 어드레스를 가리키는 레지스터입니다. RIP 레지스터는 64비트 크기입니다. RIP 레지스터는 32비트 오퍼랜드를 통해 64비트 주소 공간을 나타낼 수 있으며, RIP 상대 어드레스 방식의 어드레스 지정방식입니다.

### 세그먼트 레지스터
세그먼트 레지스터(Segment Register)는 16비트 레지스터로 어드레스 영역을 다양한 크기로 구분하는 역할을 합니다. 세그먼트 레지스터의 주된 역할은 어드레스 영역의 구분이지만, 모드마다 조금씩 역할에 차이가 있습니다. 
리얼 모드에서는 단순히 고정된 크기의 어드레스 영역을 지정하는 역할만 하지만, 보호 모드와 IA-32e 모드에서는 접근 권한(Privilege Level), 세그먼트의 시작 어드레스와 크기 등을 지정하는데 사용됩니다.
세그먼트 레지스터의 역할은 주소 공간을 목적에 따라 구분하는 것이며, 주소 공간을 구분하는 방법은 메모리 관리 기법과 관계가 깊습니다. 메모리 관리 기법에는 크게 세그먼테이션 기법과 페이징 기법 두 가지가 존재합니다. 세그먼테이션 기법은 세그먼트 레지스터를 통해 주소 공간을 구분합니다.  

**x86-64 프로세서의 세그먼트 레지스터**
| 세그먼트 레지스터 이름 | 설명 |
|---|---:|
| `CS` | 코드를 가리키는 레지스터로 데이터 이동 명령으로 값을 변경할 수 없으며, 점프 명령이나 인터럽트 관련 명령으로 변경 가능 |
| `DS` | 데이터 영역을 가리키는 레지스터로 데이터 영역에 접근할 때 암시적으로 사용 |
| `ES` | 데이터 영역을 가리키는 레지스터로 문자열과 관련된 작업을 처리할 때 암시적으로 사용 |
| `FS` | 데이터 영역을 가리키는 레지스터로 추가 레지스터를 확장하면서 생긴 레지스터이다. FS의 이름은 단순히 E 다음의 F를 붙인것이다. | 
| `SS` | 스택 영역을 가리키는 레지스터로 스택 관련 레지스터(SP, BP)를 통해 스택에 접근할 때 임시적으로 사용 |
| `GS` | 데이터 영역을 가리키는 레지스터로 추가 레지스터를 확장하면서 생긴 레지스터이다. GS의 이름은 단순히 F 다음의 G를 붙인것이다. | 

### 컨트롤 레지스터
컨트롤 레지스터(Control Register)는 운영 모드를 변경하고, 현재 운영 중인 모드의 특정 기능을 제어하는 레지스터입니다. 컨트롤 레지스터는 리얼 모드와 보호 모드일 때 32비트 크기이며, IA-32e 모드에서는 64비트로 확장되지만 일부 제약사항이 있습니다. CR0와 CR4, CR8 레지스터에서는 64비트 중 상위 32비트를 0으로 설정해야 합니다. CR2 레지스터의 경우는 64비트 영역을 모두 사용할 수 있으며, CR3 레지스터는 비트 40부터 비트 51까지 모두 0으로 설정해야 합니다.
컨트롤 레지스터는 프로세스의 운영 모드와 확장 기능을 제어하는 레지스터인 만큼 구조가 복잡합니다. 컨트롤 레지스터의 각 필드는 저마다 특정 기능을 활성화/비활성화하며, 현재 운영 모드에 따라 필수 필드와 옵션 필드가 달라집니다.  

**x86-64 프로세서의 컨트롤 레지스터 용도**
| 컨트롤 레지스터 이름 | 설명 |
|---|---:|
| `CR0` | 운영 모드를 제어하는 레지스터로 리얼모드에서 보호모드로 전환하는 역할과 캐시, 페이징 기능 등을 활성화 |
| `CR1` | 프로세서에 의해 예약된 레지스터 |
| `CR2` | 페이지 폴트 발생 시 페이지 폴트가 발생한 선형 주소가 저장되는 레지스터로 페이지 폴트 발생 시만 유효값이 대입 |
| `CR3` | 페이지 디렉터리의 물리 주소와 페이지 캐시에 관련된 기능을 설정하는 레지스터 | 
| `CR4` | 프로세서에서 지원하는 각종 확장 기능을 제어하는 레지스터로 페이지 크기 확장이나 메모리 영역 확장 등의 기능을 활성화 |
| `CR8` | 태스크 우선 순위 레지스터의 값을 제어하는 레지스터로 프로세스 외부에서 발생하는 인터럽트를 걸러주는 필터의 역할 | 

## 운영 모드와 메모리 관리 기법
x86와 x86-64 프로세서에서 지원하는 메모리 관리 기법은 두 가지가 있습니다. 한 가지는 세그먼테이션(Segmentation)이고, 또 다른 하나는 페이징(Paging)입니다. 세그먼테이션과 페이징은 주소 공간을 특정 역역으로 나눈다는 공통점이 있지만, 나누는 방식에는 차이가 있습니다. 세그먼테이션은 주소공간을 원하는 크기로 잘라서 사용하는 것이며, 페이징은 정해진 크기로 주소공간을 잘라서 사용합니다. 
메모리 관리 기법을 사용하려면 관련 레지스터에 특정한 자료구조를 설정해야 합니다. 세그먼테이션은 세그먼트 레지스터에 세그먼트의 시작 주소 혹은 디스크립터라고 불리는 자료구조의 위치를 설정해야 합니다. 페이징은 컨트롤 레지스터 중 CR3 레지스터에 페이지 디렉터리라고 불리는 자료구조의 물리 주소를 설정해야 사용할 수 있습니다. 
모든 운영 모드에 공통으로 메모리 관리 기법을 적용하면 좋지만, 모든 운영 모드가 세그먼트와 페이징을 지원하는 것은 아닙니다. 모드에 따라 지원하지 않거나 일부 기능을 제한적으로 지원합니다. 

### 리얼 모드의 메모리 관리 방식
리얼 모드는 최대 1MB까지 주소 공간을 사용하며 세그먼테이션만 지원합니다. 리얼 모드에서 세그먼트 크기는 64K로 고정이고, 세그먼트의 시작 어드레스는 세그먼트 레지스터에 직접 설정합니다. 세그먼테이션에서 세그먼트의 시작 어드레스는 코드나 메모리에 접근할 때 기준 어드레스(BaseAddress)로 사용됩니다. 
리얼 모드는 페이징을 사용하지 않으므로 물리 주소로 변화하는 방식이 비교적 간단합니다. 리얼 모드는 세그먼테이션을 거쳐 나온 어드레스가 바로 물리 주소가 됩니다. 리얼 모드의 세그먼테이션은 세그먼트 레지스터의 값에 법용 레지스터의 값을 더하는 방식으로 동작합니다. 

### 보호 모드의 메모리 관리 방식
보호 모드는 리얼 모드와 달리 세그먼테이션과 페이징을 모두 지원합니다. 보호 모드의 세그먼테이션은 리얼 모드의 세그먼테이션보다 많은 기능을 제공합니다. 보호 모드의 세그먼테이션은 세그먼트 레지스터에 세그먼트의 기준 주소를 직접 설정하는 대신 디스크립터 자료구조의 위치(Offset)를 설정하는 방식으로 바뀌었습니다. 세그먼트 레지스터의 명칭도 세그먼트 디스크립터를 선택하다는 의미에서 세그먼트 섹렉터로 변경되었습니다.
디스크립터는 메모리 영역의 정보를 저장하는 자료구조로 여러 종류가 있으며, 그중에서 세그먼트에 대한 정보를 나타내는 디스크립터를 세그먼트 디스크립터라고 부릅니다. 세그먼트 디스크립터에는 세그먼트의 시작 어드레스와 크기, 권한, 타입등의 정보가 있습니다. 

### IA-32e 모드의 메모리 관리 방식
IA-32e 모드는 두 가지 서브모드, 호환 모드와 64비트 모드가 있습니다. 호환 모드는 보호 모드와 동작이 같으므로 생략하고 64비트 모드만 설명합니다. IA-32e 모드의 64비트 모드는 64비트이므로 사용 가능한 최대 어드레스는 16EB까지입니다. 기존의 보호 모드보다 1,000,000배 이상의 공간을 자랑하지만, IA-32e 모드의 메모리 관리 기법은 보호 모드와 기본적인 부분이 같습니다. 
IA-32e 모드의 세그먼테이션은 보호 모드의 세그먼테이션과 큰 차이가 없습니다. 다만, 주소 공간이 확장되고 두 가지 서브 모드를 지원하는 등 몇 가지 기능이 추가되면서 약간의 차이가 생겼을 뿐입니다. 그 중에서 중요도 순으로 두 가지만 확인할 수 있습니다.
한 가지 차이점은 세그먼트 디스크립터에 설정된 기준 주소와 크기에 관계없이 모든 세그먼트가 기준 주소는 0, 크기는 64비트 전체로 설정된다는 것입니다.

다른 차이점은 IA-32 모드는 호환 모드와 64비트 모드의 두 가지 서브모드를 지원하므로 이를 구분하고자 코드 세그먼트 디스크립터에 L필드(비트21)가 추가된 것입니다.


## 부팅과 부트 로더






